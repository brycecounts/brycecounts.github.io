<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bryce Counts</title>
    <style>
        body {
            background-color: #999966; /* Background color */
            font-family: "Verdana", sans-serif; /* Classic font */
            color: #000000; /* Black text */
            margin: 0;
            padding: 10px; /* Adjusted padding for some space on small screens */
        }
        .content {
            max-width: 800px; /* Set a maximum width for content */
            margin: 0 auto; /* Center the content */
            padding: 20px; /* Optional padding inside the content area */
        }
        h1 {
            color: #000000; /* Black text for the header */
            text-align: left; /* Left-align the title */
            margin-left: 0;
        }
        img {
            margin: 20px 0; /* Spacing around the image */
            border: 5px solid #000000; /* Black border around the image */
            width: 200px; /* Adjust size */
            display: block;
        }
        p {
            text-align: left; /* Left-align the text */
            font-size: 16px;
        }
        a {
            color: #0000FF; /* Classic blue links */
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .links {
            text-align: left; /* Left-align the project links */
            margin-top: 20px;
        }
        .links a {
            display: block;
            margin: 10px 0;
        }
        .contact {
            text-align: center; /* Centered text */
            font-style: italic; /* Italic text for contact info */
            margin-top: 50px; /* Space above the contact info */
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Welcome to Bryce's Webpage</h1>
        <img src="Ju5x5U0-_400x400.jpg" alt="">

        <p>I am an interdisciplinary researcher in the area of overlap between philosophy of science, AI, and computational neuroscience. I am currently exploring the role that invariance plays in gradient systems (neural networks) under the assumption that gradient mechanisms are a cornerstone of intelligence/cognition. I am trying to develop models and explanations within the framework of mechanistic interpretability (MI). My primary goal is to explore the space of intelligences further, and I think a first step in this process is understanding where our class of cognitive system is located admist potential neighboring regions. There is also the tantalizing possibility of uncovering alien or counterintuitive forms of intelligence once we understand where the borders of our abilities are located and where to step beyond them. Investigating these topics has given me a strong interests in the philosophy of mathematics and probability, applied mathematics and information geometry. </p>
        
<title>Neural Network Animation</title>
    <style>
        /* Style for the canvas container */
        .network-container {
            width: 400px; /* You can adjust the width here */
            height: 300px; /* You can adjust the height here */
            background-color: #000; /* Keeps the canvas background black */
            position: relative;
            border: 1px solid white; /* Optional: for visibility of the box */
            margin: 20px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="network-container">
        <canvas id="networkCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("networkCanvas");
        const ctx = canvas.getContext("2d");

        // Setting canvas width and height to match the container size
        canvas.width = 400;  // Match this to the network-container width
        canvas.height = 300; // Match this to the network-container height

        class Neuron {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 3;
                this.alpha = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.fill();
                ctx.closePath();
            }

            updateAlpha(delta) {
                this.alpha += delta;
                if (this.alpha > 1) this.alpha = 1;
                if (this.alpha < 0) this.alpha = 0;
            }
        }

        class Connection {
            constructor(neuron1, neuron2) {
                this.neuron1 = neuron1;
                this.neuron2 = neuron2;
                this.alpha = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.neuron1.x, this.neuron1.y);
                ctx.lineTo(this.neuron2.x, this.neuron2.y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }

            updateAlpha(delta) {
                this.alpha += delta;
                if (this.alpha > 1) this.alpha = 1;
                if (this.alpha < 0) this.alpha = 0;
            }
        }

        const neurons = [];
        const connections = [];

        function createNetwork() {
            const layers = 5;
            const neuronsPerLayer = [3, 5, 7, 5, 3];
            const layerWidth = canvas.width / layers;

            for (let i = 0; i < layers; i++) {
                for (let j = 0; j < neuronsPerLayer[i]; j++) {
                    const x = i * layerWidth + layerWidth / 2;
                    const y = (canvas.height / neuronsPerLayer[i]) * (j + 1) - canvas.height / (2 * neuronsPerLayer[i]);
                    const neuron = new Neuron(x, y);
                    neurons.push(neuron);
                }
            }

            for (let i = 0; i < neurons.length - neuronsPerLayer[layers - 1]; i++) {
                for (let j = i + 1; j < neurons.length; j++) {
                    if (Math.random() < 0.3) {
                        connections.push(new Connection(neurons[i], neurons[j]));
                    }
                }
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let connection of connections) {
                connection.draw();
                connection.updateAlpha(Math.random() * 0.01 - 0.005);
            }

            for (let neuron of neurons) {
                neuron.draw();
                neuron.updateAlpha(Math.random() * 0.01 - 0.005);
            }

            requestAnimationFrame(animate);
        }

        createNetwork();
        animate();
    </script>
</body>
</html>       
        
        <!-- Contact Section -->
        <div class="contact">
            email: bc8d7@umsystem.edu<br>
	    x/twitter: https://x.com/BryceCounts0  
        </div>
    </div>
</body>
</html>
